---
title: "Data Format & Import"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Data Format & Import}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)
```

## Raw CSV from GPR software

GRootR reads CSV files **directly exported** from GPR processing software
(e.g., ImpulseRadar, REFLEXW, GPR-SLICE). No manual preprocessing is required.

A typical export looks like this:

```
Spatial Reference System:,EPSG:2178,ETRS89 / Poland CS2000 zone 7,,,,,,,,,,,,,,,,,,,,
N.,Type,Name,Category,"Colour[r,g,b]",Diameter/Height[m],Min Depth[m],Avg Depth[m],Max Depth[m],Min Altitude[m],Avg Altitude[m],Max Altitude[m],Node,X[SRS units],Y[SRS units],Depth[m],Altitude[m],Survey,Swath,Array,Channel,Propagation Velocity[cm/ns],Cross Distance[m]
1,Pipe,Feature 0010,Generic,"170, 85, 0",0.050,0.202,0.202,0.202,-0.202,-0.202,-0.202,node1,7394244.316,5578579.578,0.202,-0.202,Survey_2024.10.29_001_A_converted,Swath003,600 VV,0,16.877,3.505,
,,,,,,,,,,,,node2,7394245.057,5578579.786,0.202,-0.202,Survey_2024.10.29_001_A_converted,Swath003,600 VV,3,16.877,2.739,
,,,,,,,,,,,,node3,7394245.455,5578580.134,0.202,-0.202,Survey_2024.10.29_001_A_converted,Swath003,600 VV,10,16.877,2.296,
2,Pipe,Feature 0011,Generic,"170, 85, 0",0.050,0.202,0.202,0.202,-0.202,-0.202,-0.202,node1,7394244.185,5578580.438,0.202,-0.202,Survey_2024.10.29_001_A_converted,Swath003,600 VV,20,16.877,3.545,
,,,,,,,,,,,,node2,7394244.656,5578580.969,0.202,-0.202,Survey_2024.10.29_001_A_converted,Swath005,600 VV,8,16.877,2.981,
```

### Structure breakdown

**Row 1** — CRS metadata. Skipped automatically (`skip = 1`).

**Row 2** — Column headers.

**Rows 3+** — Data. Each detected root is a group of consecutive rows:

| Column | Present in | Description |
|---|---|---|
| `N.` | First node only | Root identifier (integer). Empty for continuation rows — filled forward by GRootR. |
| `Type` | First node only | Object type (e.g., "Pipe"). |
| `Name` | First node only | Feature name from GPR software (e.g., "Feature 0010"). |
| `Category` | First node only | Category label (e.g., "Generic"). |
| `Colour[r,g,b]` | First node only | Display colour. |
| `Diameter/Height[m]` | First node only | Estimated diameter. |
| `Min/Avg/Max Depth[m]` | First node only | Depth summary for entire root. |
| `Min/Avg/Max Altitude[m]` | First node only | Altitude summary. |
| `Node` | Every row | Node label: `node1`, `node2`, etc. |
| `X[SRS units]` | Every row | X coordinate in the projected CRS. |
| `Y[SRS units]` | Every row | Y coordinate in the projected CRS. |
| `Depth[m]` | Every row | Depth below surface (positive = underground). |
| `Altitude[m]` | Every row | Altitude (negative of depth). |
| `Survey` | Every row | Composite scan identifier. |
| `Swath` | Every row | Swath/scan line name. |
| `Array` | Every row | Antenna array configuration. |
| `Channel` | Every row | GPR channel number. |
| `Propagation Velocity[cm/ns]` | Every row | Wave velocity. |
| `Cross Distance[m]` | Every row | Cross-line distance. |

The critical columns for GRootR are: **`N.`**, **`Node`**, **`X[SRS units]`**,
**`Y[SRS units]`**, **`Depth[m]`**, and optionally **`Survey`**.

## Loading with defaults

For standard GPR exports, the defaults work out of the box:

```{r}
library(GRootR)

df <- prepare_root_data("gpr_export.csv")
```

This is equivalent to:

```{r}
df <- load_root_csv("gpr_export.csv", sep = ",", skip = 1, root_id_col = "N.")
df <- split_survey_column(df, survey_col = "Survey", plot_position = 4)
df <- convert_coordinates(df, x_col = "X[SRS units]",
                          y_col = "Y[SRS units]", z_col = "Depth[m]")
```

## Custom column names

If your GPR software uses different column names:

```{r}
df <- load_root_csv("my_data.csv", sep = ";", skip = 0,
                    root_id_col = "RootNumber")

df <- convert_coordinates(df, x_col = "Easting", y_col = "Northing",
                          z_col = "DepthMeters")
```

## The Survey column

The Survey column typically encodes scan metadata in a composite string:

```
Survey_2024.10.29_001_A_converted
  │       │        │   │     │
  │       │        │   │     └── processing status
  │       │        │   └──────── plot ID (position 4)
  │       │        └──────────── scan number
  │       └───────────────────── date
  └───────────────────────────── prefix
```

`split_survey_column()` splits by `_` and extracts the plot ID:

```{r}
# Default: 4th part → "A"
df <- split_survey_column(df, plot_position = 4)

# If your plot ID is elsewhere:
df <- split_survey_column(df, plot_position = 3)
```

If you don't need the plot ID, skip it:

```{r}
df <- prepare_root_data("data.csv", survey_col = NULL)
```

## Coordinate Reference System

GRootR preserves whatever CRS your coordinates are in. You specify the EPSG
code when building segments:

```{r}
# Polish CS2000 zone 7 (common for GPR data from Poland)
segments <- process_all_roots(df, crs = 2178)

# UTM zone 33N
segments <- process_all_roots(df, crs = 32633)
```

Use a **projected** CRS (meters). Geographic CRS (degrees) will produce
meaningless distances and areas.

## Tree location data

For joining roots with trees, provide a spatial file with tree stem
positions as points:

```{r}
library(sf)
trees <- st_read("trees.shp")

# Or from CSV:
trees <- read.csv("trees.csv") |>
  st_as_sf(coords = c("X", "Y"), crs = 2178)
```

The tree data needs an ID column (any name) and point geometry.
CRS matching is handled automatically during the join.
